<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="数组 # 数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。
初始化 # Go语言数组有两个声明初始化方式，一种需要显示指明数组大小，另一种使用 ...保留字， 数组的长度将由编译器在编译阶段推断出来：
arr1 := [3]int{1, 2, 3} // 使用[n]T方式 arr2 := [...]int{1, 2, 3} // 使用[...]T方式 arr3 := [3]int{2: 3} // 使用[n]T方式 arr4 := [...]int{2: 3} // 使用[...]T方式 注意：
上面代码中arr3和arr4的初始化方式是指定数组索引对应的值。这种方式并不常见。
可比较性 # 数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。
func main() { var a1 [3]int var a2 [3]int var a3 [5]int fmt.Println(a1 == a2) // 输出true fmt.Println(a1 == a3) // 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int) } 值类型 # Go语言中数组是一个值类型变量，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="数组" />
<meta property="og:description" content="数组 # 数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。
初始化 # Go语言数组有两个声明初始化方式，一种需要显示指明数组大小，另一种使用 ...保留字， 数组的长度将由编译器在编译阶段推断出来：
arr1 := [3]int{1, 2, 3} // 使用[n]T方式 arr2 := [...]int{1, 2, 3} // 使用[...]T方式 arr3 := [3]int{2: 3} // 使用[n]T方式 arr4 := [...]int{2: 3} // 使用[...]T方式 注意：
上面代码中arr3和arr4的初始化方式是指定数组索引对应的值。这种方式并不常见。
可比较性 # 数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。
func main() { var a1 [3]int var a2 [3]int var a3 [5]int fmt.Println(a1 == a2) // 输出true fmt.Println(a1 == a3) // 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int) } 值类型 # Go语言中数组是一个值类型变量，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://go.cyub.vip/type/array/" /><meta property="article:section" content="type" />


<title>数组 | 深入Go语言之旅</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.f06572240ce28e67eb332ac5cf5d59a696c47ad4c6f700d5842c5ed93dd8ec77.css" integrity="sha256-8GVyJAzijmfrMyrFz11ZppbEetTG9wDVhCxe2T3Y7Hc=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.3d1195962e1207ac62fb79bead4581c42faf33a74b0256c39d11bda86fbacd95.js" integrity="sha256-PRGVli4SB6xi&#43;3m&#43;rUWBxC&#43;vM6dLAlbDnRG9qG&#43;6zZU=" crossorigin="anonymous"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-BQ229RRTTX"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-BQ229RRTTX', { 'anonymize_ip': false });
}
</script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="https://static.cyub.vip/images/202310/golang-480.png" alt="Logo" /><span>深入Go语言之旅</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://www.cyub.vip/"  target="_blank" rel="noopener">
        个人博客
      </a>
  </li>
  
  <li>
    <a href="https://github.com/cyub"  target="_blank" rel="noopener">
        Github主页
      </a>
  </li>
  
  <li>
    <a href="https://www.topgoer.cn/?ref=go.cyub.vip"  target="_blank" rel="noopener">
        地鼠文档
      </a>
  </li>
  
</ul>







  <ul>
<li>
<p><strong>
  <a href="/">深入Go语言之旅</a></strong></p>
</li>
<li>
<p><strong>准备篇</strong></p>
<ul>
<li>
  <a href="/compiler/">编译流程</a></li>
<li>
  <a href="/analysis-tools/">分析工具</a>
<ul>
<li>
  <a href="/analysis-tools/gdb/">GDB</a></li>
<li>
  <a href="/analysis-tools/dlv/">Delve</a></li>
<li>
  <a href="/analysis-tools/go-buildin-tools/">Go 内置工具</a></li>
</ul>
</li>
<li>
  <a href="/go-assembly/">Go汇编</a></li>
</ul>
</li>
<li>
<p><strong>基础篇</strong></p>
<ul>
<li>
  <a href="/type/">数据类型与数据结构</a>
<ul>
<li>
  <a href="/type/string/">字符串</a></li>
<li>
  <a href="/type/array/"class=active>数组</a></li>
<li>
  <a href="/type/slice/">切片</a></li>
<li>
  <a href="/type/nil/">nil</a></li>
<li>
  <a href="/type/empty_struct/">空结构体</a></li>
<li>
  <a href="/type/pointer/">指针</a></li>
<li>
  <a href="/type/map/">映射</a></li>
</ul>
</li>
<li>
  <a href="/function/">函数</a>
<ul>
<li>
  <a href="/function/first-class/">一等公民</a></li>
<li>
  <a href="/function/call-stack/">函数调用栈</a></li>
<li>
  <a href="/function/pass-by-value/">值传递</a></li>
<li>
  <a href="/function/closure/">闭包</a></li>
<li>
  <a href="/function/method/">方法</a></li>
</ul>
</li>
<li>
  <a href="/feature/">语言特性</a>
<ul>
<li>
  <a href="/feature/comma-ok/">逗号ok模式</a></li>
<li>
  <a href="/feature/for-range/">遍历 - for-range语法</a></li>
<li>
  <a href="/feature/defer/">延迟执行 - defer语法</a></li>
<li>
  <a href="/feature/select/">通道选择器 - select语法</a></li>
<li>
  <a href="/feature/panic-recover/">恐慌与恢复  - panic/recover</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>运行时篇</strong></p>
<ul>
<li>
  <a href="/concurrency/">并发编程</a>
<ul>
<li>
  <a href="/concurrency/memory-model/">内存模型</a></li>
<li>
  <a href="/concurrency/context/">上下文 - context</a></li>
<li>
  <a href="/concurrency/channel/">通道 - channel</a></li>
<li>
  <a href="/concurrency/atomic/">原子操作 - atomic</a></li>
<li>
  <a href="/concurrency/sync-map/">并发Map - sync.Map</a></li>
<li>
  <a href="/concurrency/sync-waitgroup/">等待组 - sync.WaitGroup</a></li>
<li>
  <a href="/concurrency/sync-once/">一次性操作 - sync.Once</a></li>
<li>
  <a href="/concurrency/sync-pool/">缓冲池 - sync.Pool</a></li>
<li>
  <a href="/concurrency/sync-cond/">条件变量 - sync.Cond</a></li>
<li>
  <a href="/concurrency/sync-mutex/">互斥锁 - sync.Mutex</a></li>
<li>
  <a href="/concurrency/sync-rwmutex/">读写锁 - sync.RWMutex</a></li>
</ul>
</li>
<li>
  <a href="/gmp/">G-M-P调度机制</a>
<ul>
<li>
  <a href="/gmp/gmp-model/">调度机制概述</a></li>
<li>
  <a href="/gmp/scheduler/">调度器</a></li>
</ul>
</li>
<li>
  <a href="/memory/">内存管理</a>
<ul>
<li>
  <a href="/memory/allocator/">内存分配器</a></li>
<li>
  <a href="/memory/gc/">GC</a></li>
</ul>
</li>
<li>
  <a href="/type-system/">类型系统</a>
<ul>
<li>
  <a href="/type-system/type/">类型系统</a></li>
<li>
  <a href="/type-system/interface/">接口</a></li>
<li>
  <a href="/type-system/reflect/">反射</a></li>
</ul>
</li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>数组</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="数组">
  数组
  <a class="anchor" href="#%e6%95%b0%e7%bb%84">#</a>
</h1>
<p>数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。</p>
<h2 id="初始化">
  初始化
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96">#</a>
</h2>
<p>Go语言数组有两个声明初始化方式，一种需要显示指明数组大小，另一种使用 <code>...</code>保留字， 数组的长度将由编译器在编译阶段推断出来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">arr1</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[n]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr2</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[...]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr3</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[n]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr4</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[...]T方式
</span></span></span></code></pre></div><blockquote class="book-hint info">
  <p><strong>注意：</strong></p>
<p>上面代码中arr3和arr4的初始化方式是指定数组索引对应的值。这种方式并不常见。</p>

</blockquote>

<h2 id="可比较性">
  可比较性
  <a class="anchor" href="#%e5%8f%af%e6%af%94%e8%be%83%e6%80%a7">#</a>
</h2>
<p>数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a1</span>  [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a2</span>  [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a3</span>  [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">a2</span>) <span style="color:#75715e">// 输出true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">a3</span>) <span style="color:#75715e">// 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="值类型">
  值类型
  <a class="anchor" href="#%e5%80%bc%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>Go语言中数组是一个值类型变量，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">passArr</span>(<span style="color:#a6e22e">arr</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">myArr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">passArr</span>(<span style="color:#a6e22e">myArr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">myArr</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">// 输出1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="空间局部性与时间局部性">
  空间局部性与时间局部性
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7%e4%b8%8e%e6%97%b6%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7">#</a>
</h2>
<p>CPU访问数据时候，趋于访问同一片内存区域的数据，这个称为 <strong>局部性原理（principle of locality）</strong>。局部性原理可以为细分为 <strong>空间局部性（Spatial Locality）</strong> 和 <strong>时间局部性（Temporal Locality）</strong>。</p>
<ul>
<li>
<p>空间局部性</p>
<p>指的是如果一个位置的数据被访问，那么它周围的数据也有可能被访问到。</p>
</li>
<li>
<p>时间局部性</p>
<p>指的是如果一个位置的数据被访问到，那么它下一次还是很有可能被访问到。所以我们可以把最近访问的数据缓存起来，内存淘汰算法LRU就是基于这个原理。</p>
</li>
</ul>
<p>我们知道数组内存空间是连续分配的，比如对于[3][5]int类型数组其内存空间分配使用如下图所示：</p>
<figure class="text-center"><img src="https://static.cyub.vip/images/202104/array_memory_alloc.png" width="400px"/><figcaption>
            <h4>二维数组内存布局</h4>
        </figcaption>
</figure>

<p>观察上面的二维数组的内存布局，我们可以得出对于 <code>[m][n]T</code> 类型的数组中任一个元素内存地址的计算公式是：</p>
<pre tabindex="0"><code>数组元素的内存地址 = 第一个数组元素的内存地址 + 该元素跨过了多少行 * 元素类型大小 + 该元素在当前行的位置 * 元素类型大小
</code></pre><p>转换成伪码的实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">x</span>][<span style="color:#a6e22e">y</span>]) = <span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>)
</span></span><span style="display:flex;"><span>				   = <span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>)
</span></span></code></pre></div><p>下面我们根据上面公式来访问数组中元素，下面代码中使用到了 <code>uintptr</code> 和 <code>unsafe.Pointer</code>，如果不太了解的话可以看本书的 《<strong>
  <a href="/type/pointer/">基础篇-指针</a></strong>》 那一章节：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#75715e">// 地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;arr[%d][%d]: 地址 = 0x%x，值 = %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">addr</span>, <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>))))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码运行结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068ef0，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068ef8，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068f00，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068f08，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068f10，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>arr<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>: 地址 <span style="color:#f92672">=</span> 0xc000068f18，值 <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span></code></pre></div><h3 id="空间局部性示例">
  空间局部性示例
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7%e7%a4%ba%e4%be%8b">#</a>
</h3>
<p>对于数组的访问，我们可以一行行访问，也可以一列列访问，根据上面分析我们可以得出<strong>一行行访问可以有很好的空间局部性，有更好的执行效率</strong>的结论。因为一行行访问时，下一次访问的就是当前元素挨着的元素，而一列列访问则是需要跨过数组列数个元素：</p>
<figure class="text-center"><img src="https://static.cyub.vip/images/202104/multi_dimen_array.png" width="400px"/><figcaption>
            <h4>二位数组的访问</h4>
        </figcaption>
</figure>

<p>最后我们来进行下基准测试验证一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkAccessArrayByRow</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">myArr</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">myArr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkAccessArrayByCol</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">myArr</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">myArr</span>[<span style="color:#a6e22e">j</span>][<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>本人电脑中基准测试结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>goos: linux
</span></span><span style="display:flex;"><span>goarch: amd64
</span></span><span style="display:flex;"><span>BenchmarkAccessArrayByRow 	121336255	        10.3 ns/op	       <span style="color:#ae81ff">0</span> B/op	       <span style="color:#ae81ff">0</span> allocs/op
</span></span><span style="display:flex;"><span>BenchmarkAccessArrayByCol 	82772149	        13.2 ns/op	       <span style="color:#ae81ff">0</span> B/op	       <span style="color:#ae81ff">0</span> allocs/op
</span></span><span style="display:flex;"><span>PASS
</span></span></code></pre></div><p>从上面结果可以看出来，我们可以发现按行访问（10.3 ns/op）快于按列访问（13.2 ns/op），符合我们预测的结论。</p>
<h2 id="如何实现随机访问数组的全部元素">
  如何实现随机访问数组的全部元素？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e6%95%b0%e7%bb%84%e7%9a%84%e5%85%a8%e9%83%a8%e5%85%83%e7%b4%a0">#</a>
</h2>
<p>这里将介绍两种实现方法。这两种实现方法都是Go语言底层使用到的算法。</p>
<p>第一种方法用在Go调度器部分。G-M-P调度模型中，当M关联的P的本地队列中没有可以执行的G时候，M会从其他P的本地可运行G队列中偷取G，所有P存储一个全局切片中，为了随机性选择P来偷取，这就需要随机的访问数组。该算法具体叫什么，未找到相关文档。由于该算法实现上使用到素数和取模运算，姑且称之素数取模随机法。</p>
<p>第二种方法使用算法<code>Fisher–Yates shuffle</code>，Go语言用它来随机性处理通道选择器select中case语句。</p>
<h3 id="素数取模随机法">
  素数取模随机法
  <a class="anchor" href="#%e7%b4%a0%e6%95%b0%e5%8f%96%e6%a8%a1%e9%9a%8f%e6%9c%ba%e6%b3%95">#</a>
</h3>
<p>该算法实现逻辑是：对于一个数组[n]T，随机的从小于n的素数集合中，选择一个素数，假定是p，接着从数组0到n-1位置中随机选择一个位置开始，假定是m，那么此时<code>(m + p)%n = i</code>位置处的数组元素就是我们要访问的第一个元素。第二次要访问的元素是<code>(上一次位置+p)%n</code>处元素，这里面就是<code>(i+p)%n</code>，以此类推，访问n次就可以访问完全部数组元素。</p>
<p>举个具体例子来说明，比如对于[8]int数组a，其素数集合是{1, 3, 5, 7}。假定选择的素数是5，从位置1开始。</p>
<ul>
<li>第一次访问元素是 (1 + 5)%8 = 6处元素，即a[6]</li>
<li>第二次访问元素是 (6 + 5)%8 = 3处元素，即a[3]</li>
<li>第三次访问元素是 (3 + 5)%8 = 0处元素，即a[0]</li>
<li>第四次访问元素是 (0 + 5)%8 = 5处元素，即a[5]</li>
<li>第五次访问元素是 (5 + 5)%8 = 2处元素，即a[2]</li>
<li>第六次访问元素是 (2 + 5)%8 = 7处元素，即a[7]</li>
<li>第七次访问元素是 (7 + 5)%8 = 4处元素，即a[4]</li>
<li>第八次访问元素是 (4 + 5)%8 = 1处元素，即a[1]</li>
</ul>
<p>从上面例子可以看出来访问8次即可遍历完所有数组元素，由于素数和开始位置是随机的，那么访问也能做到随机性。</p>
<p>该算法实现如下，代码来自Go源码 <strong>
  <a href="https://github.com/golang/go/blob/go1.14.13/src/runtime/proc.go#L5403-L5451">runtime/proc.go</a></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">randomOrder</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span>    <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">coprimes</span> []<span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">randomEnum</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span>     <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pos</span>   <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span>   <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ord</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomOrder</span>) <span style="color:#a6e22e">reset</span>(<span style="color:#a6e22e">count</span> <span style="color:#66d9ef">uint32</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span> = <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span> = <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>[:<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#ae81ff">1</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 初始化素数集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">count</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span> = append(<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ord</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomOrder</span>) <span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#a6e22e">randomEnum</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">randomEnum</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">count</span>: <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pos</span>:   <span style="color:#a6e22e">i</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">inc</span>:   <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">%</span>uint32(len(<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>))],
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">done</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span> = (<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">inc</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">position</span>() <span style="color:#66d9ef">uint32</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#66d9ef">uint32</span> { <span style="color:#75715e">// 辗转相除法取最大公约数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">%</span><span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">8</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">order</span> <span style="color:#a6e22e">randomOrder</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">reset</span>(uint32(len(<span style="color:#a6e22e">arr</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;====第一次随机遍历====&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">enum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Uint32</span>()); !<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">done</span>(); <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">position</span>()])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;====第二次随机遍历====&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">enum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Uint32</span>()); !<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">done</span>(); <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">position</span>()])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="fisheryates-shuffle">
  Fisher–Yates shuffle
  <a class="anchor" href="#fisheryates-shuffle">#</a>
</h3>
<h2 id="进一步阅读">
  进一步阅读
  <a class="anchor" href="#%e8%bf%9b%e4%b8%80%e6%ad%a5%e9%98%85%e8%af%bb">#</a>
</h2>
<ul>
<li>
  <a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a></li>
<li>
  <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm">Fisher–Yates_shuffle</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

<script src="https://giscus.app/client.js" data-repo="cyub/go-1.14.13"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzMzc2ODUyMzQ=" data-category="Announcements"
    data-category-id="DIC_kwDOFCCq8s4CZ3BC"
    data-mapping="pathname" data-strict="0" data-emit-metadata="0"
    data-input-position="bottom" data-reactions-enabled="0"
    data-lang="zh-CN" data-theme="preferred_color_scheme" crossorigin="anonymous" async>
    </script>
<noscript>Please enable JavaScript to view the comments powered by giscus.</noscript>
</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
</body>
</html>












