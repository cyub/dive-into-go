<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="数组 # 数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。
初始化 # Go语言数组有两个声明初始化方式，一个需要显示指明数组大小，另一个使用...由编译器在编译阶段推断出来：
arr1 := [3]int{1, 2, 3} // 使用[n]T方式 arr2 := [...]int{1, 2, 3} // 使用[...]T方式 arr3 := [3]int{2: 3} // 使用[n]T方式 arr4 := [...]int{2: 3} // 使用[...]T方式 .. hint:: 上面代码中arr3和arr4的初始化方式，是指定数组索引对应的值。这种方式并不常见。 可比较性 # 数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。
func main() { var a1 [3]int var a2 [3]int var a3 [5]int fmt.Println(a1 == a2) // 输出true fmt.Println(a1 == a3) // 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int) } 值类型 # Go语言中数组是一个值类型，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="数组" />
<meta property="og:description" content="数组 # 数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。
初始化 # Go语言数组有两个声明初始化方式，一个需要显示指明数组大小，另一个使用...由编译器在编译阶段推断出来：
arr1 := [3]int{1, 2, 3} // 使用[n]T方式 arr2 := [...]int{1, 2, 3} // 使用[...]T方式 arr3 := [3]int{2: 3} // 使用[n]T方式 arr4 := [...]int{2: 3} // 使用[...]T方式 .. hint:: 上面代码中arr3和arr4的初始化方式，是指定数组索引对应的值。这种方式并不常见。 可比较性 # 数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。
func main() { var a1 [3]int var a2 [3]int var a3 [5]int fmt.Println(a1 == a2) // 输出true fmt.Println(a1 == a3) // 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int) } 值类型 # Go语言中数组是一个值类型，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://go.cyub.vip/type/array/" /><meta property="article:section" content="type" />


<title>数组 | 深入Go语言之旅</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.f06572240ce28e67eb332ac5cf5d59a696c47ad4c6f700d5842c5ed93dd8ec77.css" integrity="sha256-8GVyJAzijmfrMyrFz11ZppbEetTG9wDVhCxe2T3Y7Hc=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.7e9d53d4a20eea8c87bf76a4502bd21aa041c1ef2adc7e37ffc5339c57accccd.js" integrity="sha256-fp1T1KIO6oyHv3akUCvSGqBBwe8q3H43/8UznFeszM0=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="https://static.cyub.vip/images/202310/golang-480.png" alt="Logo" /><span>深入Go语言之旅</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://www.cyub.vip/"  target="_blank" rel="noopener">
        个人博客
      </a>
  </li>
  
  <li>
    <a href="https://github.com/cyub"  target="_blank" rel="noopener">
        Github主页
      </a>
  </li>
  
  <li>
    <a href="https://www.topgoer.cn/?ref=go.cyub.vip"  target="_blank" rel="noopener">
        地鼠文档
      </a>
  </li>
  
</ul>







  <ul>
<li>
<p><strong>准备篇</strong></p>
<ul>
<li>
  <a href="/compiler/">编译流程</a></li>
<li>
  <a href="/analysis-tools/">分析工具</a>
<ul>
<li>
  <a href="/analysis-tools/gdb/">GDB</a></li>
<li>
  <a href="/analysis-tools/dlv/">Delve</a></li>
<li>
  <a href="/analysis-tools/go-buildin-tools/">Go 内置工具</a></li>
</ul>
</li>
<li>
  <a href="/go-assembly/">Go汇编</a></li>
</ul>
</li>
<li>
<p><strong>基础篇</strong></p>
<ul>
<li>
  <a href="/type/">数据类型与数据结构</a>
<ul>
<li>
  <a href="/type/string/">字符串</a></li>
<li>
  <a href="/type/array/"class=active>数组</a></li>
<li>
  <a href="/type/slice/">切片</a></li>
<li>
  <a href="/type/nil/">nil</a></li>
<li>
  <a href="/type/empty_struct/">空结构体</a></li>
<li>
  <a href="/type/pointer/">指针</a></li>
<li>
  <a href="/type/map/">映射</a></li>
</ul>
</li>
<li>
  <a href="/function/">函数</a>
<ul>
<li>
  <a href="/function/first-class/">一等公民</a></li>
<li>
  <a href="/function/call-stack/">函数调用栈</a></li>
<li>
  <a href="/function/pass-by-value/">值传递</a></li>
<li>
  <a href="/function/closure/">闭包</a></li>
<li>
  <a href="/function/method/">方法</a></li>
</ul>
</li>
<li>
  <a href="/feature/">语言特性</a>
<ul>
<li>
  <a href="/feature/comma-ok/">逗号ok模式</a></li>
<li>
  <a href="/feature/for-range/">遍历 - for-range语法</a></li>
<li>
  <a href="/feature/defer/">延迟执行 - defer语法</a></li>
<li>
  <a href="/feature/select/">通道选择器 - select语法</a></li>
<li>
  <a href="/feature/panic-recover/">恐慌与恢复  - panic/recover</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>运行时篇</strong></p>
<ul>
<li>
  <a href="/concurrency/">并发编程</a>
<ul>
<li>
  <a href="/concurrency/memory-model/">内存模型</a></li>
<li>
  <a href="/concurrency/context/">上下文 - context</a></li>
<li>
  <a href="/concurrency/channel/">通道 - channel</a></li>
<li>
  <a href="/concurrency/atomic/">原子操作 - atomic</a></li>
<li>
  <a href="/concurrency/sync-map/">并发Map - sync.Map</a></li>
<li>
  <a href="/concurrency/sync-waitgroup/">等待组 - sync.WaitGroup</a></li>
<li>
  <a href="/concurrency/sync-once/">一次性操作 - sync.Once</a></li>
<li>
  <a href="/concurrency/sync-pool/">缓冲池 - sync.Pool</a></li>
<li>
  <a href="/concurrency/sync-cond/">条件变量 - sync.Cond</a></li>
<li>
  <a href="/concurrency/sync-mutex/">互斥锁 - sync.Mutex</a></li>
<li>
  <a href="/concurrency/sync-rwmutex/">读写锁 - sync.RWMutex</a></li>
</ul>
</li>
<li>
  <a href="/gmp/">G-M-P调度机制</a>
<ul>
<li>
  <a href="/gmp/gmp-model/">调度机制概述</a></li>
<li>
  <a href="/gmp/scheduler/">调度器</a></li>
</ul>
</li>
<li>
  <a href="/memory/">内存管理</a>
<ul>
<li>
  <a href="/memory/allocator/">内存分配器</a></li>
<li>
  <a href="/memory/gc/">GC</a></li>
</ul>
</li>
<li>
  <a href="/type-system/">类型系统</a>
<ul>
<li>
  <a href="/type-system/type/">类型系统</a></li>
<li>
  <a href="/type-system/interface/">接口</a></li>
<li>
  <a href="/type-system/reflect/">反射</a></li>
</ul>
</li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>数组</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="数组">
  数组
  <a class="anchor" href="#%e6%95%b0%e7%bb%84">#</a>
</h1>
<p>数组是Go语言中常见的数据结构，相比切片，数组我们使用的比较少。</p>
<h2 id="初始化">
  初始化
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96">#</a>
</h2>
<p>Go语言数组有两个声明初始化方式，一个需要显示指明数组大小，另一个使用<code>...</code>由编译器在编译阶段推断出来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">arr1</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[n]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr2</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[...]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr3</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[n]T方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr4</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 使用[...]T方式
</span></span></span></code></pre></div><pre tabindex="0"><code class="language-eval_rst" data-lang="eval_rst">.. hint:: 上面代码中arr3和arr4的初始化方式，是指定数组索引对应的值。这种方式并不常见。
</code></pre><h2 id="可比较性">
  可比较性
  <a class="anchor" href="#%e5%8f%af%e6%af%94%e8%be%83%e6%80%a7">#</a>
</h2>
<p>数组大小是数组类型的一部分，只有数组大小和数组元素类型一样的数组才能够进行比较。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a1</span>  [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a2</span>  [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a3</span>  [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">a2</span>) <span style="color:#75715e">// 输出true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">a3</span>) <span style="color:#75715e">// 不能够比较，会报编译错误： invalid operation: a1 == a3 (mismatched types [3]int and [5]int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="值类型">
  值类型
  <a class="anchor" href="#%e5%80%bc%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>Go语言中数组是一个值类型，将一个数组作为函数参数传递是拷贝原数组形成一个新数组传递，在函数里面对数组做任何更改都不会影响原数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">passArr</span>(<span style="color:#a6e22e">arr</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">myArr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">passArr</span>(<span style="color:#a6e22e">myArr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">myArr</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">// 输出1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="空间局部性与时间局部性">
  空间局部性与时间局部性
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7%e4%b8%8e%e6%97%b6%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7">#</a>
</h2>
<p>CPU访问数据时候，趋于访问同一片内存区域的数据，这个称为局部性原理（principle of locality）。局部性原理可以为分为空间局部性（Spatial Locality）和时间局部性（Temporal Locality）。</p>
<ul>
<li>
<p>空间局部性</p>
<p>指的是如果一个位置的数据被访问，那么它周围的数据也有可能被访问到。</p>
</li>
<li>
<p>时间局部性</p>
<p>指的是如果一个位置的数据被访问到，那么它下一次还是很有可能被访问到。所以我们可以把最近访问的数据缓存起来，内存淘汰算法LRU就是基于这个原理。</p>
</li>
</ul>
<p>我们知道数组内存空间是连续分配的，比如对于[3][5]int类型数组其内存空间分配使用如下图所示：</p>
<pre tabindex="0"><code class="language-eval_rst" data-lang="eval_rst">.. image:: https://static.cyub.vip/images/202104/array_memory_alloc.png
    :alt: 二位数组访问
    :width: 400px
    :align: center
</code></pre><p>推而广之，对于[m][n]T类型的数组中某一个元素内存地址的计算公式是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 数组元素的内存地址 = 第一个数组元素的内存地址 + 该元素跨过了多少行 * 元素类型大小 + 该元素在当前行的位置 * 元素类型大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">x</span>][<span style="color:#a6e22e">y</span>]) = <span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>)
</span></span><span style="display:flex;"><span> = <span style="color:#a6e22e">address</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">T</span>)
</span></span></code></pre></div><p>下面我们根据上面公式来访问一个数组，下面代码中使用到了<code>uintptr</code>和<code>unsafe.Pointer</code>，如果不太了解的话可以看本书的
  <a href="/type/pointer/">指针</a>那一章节：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#75715e">// 地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;arr[%d][%d]: 地址 = 0x%x，值 = %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">addr</span>, <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>])) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>))))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码运行结果如下：</p>
<pre tabindex="0"><code>arr[0][0]: 地址 = 0xc000068ef0，值 = 1
arr[0][1]: 地址 = 0xc000068ef8，值 = 2
arr[0][2]: 地址 = 0xc000068f00，值 = 3
arr[1][0]: 地址 = 0xc000068f08，值 = 4
arr[1][1]: 地址 = 0xc000068f10，值 = 5
arr[1][2]: 地址 = 0xc000068f18，值 = 6
</code></pre><h3 id="空间局部性示例">
  空间局部性示例
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e5%b1%80%e9%83%a8%e6%80%a7%e7%a4%ba%e4%be%8b">#</a>
</h3>
<p>对于数组的访问，我们可以一行行访问，也可以一列列访问，根据上面分析我们可以得出<strong>一行行访问可以有很好的空间局部性，有更好的执行效率</strong>的结论。因为一行行访问时，下一次访问的就是当前元素挨着的元素，而一列列访问则是需要跨过数组列数个元素：</p>
<pre tabindex="0"><code class="language-eval_rst" data-lang="eval_rst">.. image:: https://static.cyub.vip/images/202104/multi_dimen_array.png
    :alt: 二位数组访问
    :width: 400px
    :align: center
</code></pre><p>最后我们来进行下基准测试验证一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkAccessArrayByRow</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">myArr</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">myArr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkAccessArrayByCol</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">myArr</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">myArr</span>[<span style="color:#a6e22e">j</span>][<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>本人电脑中基准测试结果如下：</p>
<pre tabindex="0"><code>goos: linux
goarch: amd64
BenchmarkAccessArrayByRow 	121336255	        10.3 ns/op	       0 B/op	       0 allocs/op
BenchmarkAccessArrayByCol 	82772149	        13.2 ns/op	       0 B/op	       0 allocs/op
PASS
</code></pre><p>从上面结果可以看出来，我们可以发现按行访问（10.3 ns/op）快于按列访问（13.2 ns/op）验证我们的结论。</p>
<h2 id="如何实现随机访问数组的全部元素">
  如何实现随机访问数组的全部元素？
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e6%95%b0%e7%bb%84%e7%9a%84%e5%85%a8%e9%83%a8%e5%85%83%e7%b4%a0">#</a>
</h2>
<p>这里将介绍两种实现方法。这两种实现方法都是Go语言底层使用到的算法。</p>
<p>第一种方法用在Go调度器部分。GMP调度模型中，当M关联的P的本地队列中没有可以执行的G时候，M会从其他P的本地可运行G队列中偷取G，所有P存储一个全局切片中，为了随机性选择P来偷取，这就需要随机的访问数组。该算法具体叫什么，未找到相关文档。由于该算法实现上使用到素数和取模运算，姑且称之素数取模随机法。</p>
<p>第二种方法使用算法<code>Fisher–Yates shuffle</code>，Go语言用它来随机性处理通道选择器select中case语句。</p>
<h3 id="素数取模随机法">
  素数取模随机法
  <a class="anchor" href="#%e7%b4%a0%e6%95%b0%e5%8f%96%e6%a8%a1%e9%9a%8f%e6%9c%ba%e6%b3%95">#</a>
</h3>
<p>该算法实现逻辑是：对于一个数组[n]T，随机的从小于n的素数集合中，选择一个素数，假定是p，接着从数组0到n-1位置中随机选择一个位置开始，假定是m，那么此时<code>(m + p)%n = i</code>位置处的数组元素就是我们要访问的第一个元素。第二次要访问的元素是<code>(上一次位置+p)%n</code>处元素，这里面就是<code>(i+p)%n</code>，以此类推，访问n次就可以访问完全部数组元素。</p>
<p>举个具体例子来说明，比如对于[8]int数组a，其素数集合是{1, 3, 5, 7}。假定选择的素数是5，从位置1开始。</p>
<ul>
<li>第一次访问元素是 (1 + 5)%8 = 6处元素，即a[6]</li>
<li>第二次访问元素是 (6 + 5)%8 = 3处元素，即a[3]</li>
<li>第三次访问元素是 (3 + 5)%8 = 0处元素，即a[0]</li>
<li>第四次访问元素是 (0 + 5)%8 = 5处元素，即a[5]</li>
<li>第五次访问元素是 (5 + 5)%8 = 2处元素，即a[2]</li>
<li>第六次访问元素是 (2 + 5)%8 = 7处元素，即a[7]</li>
<li>第七次访问元素是 (7 + 5)%8 = 4处元素，即a[4]</li>
<li>第八次访问元素是 (4 + 5)%8 = 1处元素，即a[1]</li>
</ul>
<p>从上面例子可以看出来访问8次即可遍历完所有数组元素，由于素数和开始位置是随机的，那么访问也能做到随机性。</p>
<p>该算法实现如下，代码来自Go源码
  <a href="https://github.com/golang/go/blob/go1.14.13/src/runtime/proc.go#L5403-L5451">runtime/proc.go</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">randomOrder</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span>    <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">coprimes</span> []<span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">randomEnum</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span>     <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pos</span>   <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span>   <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ord</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomOrder</span>) <span style="color:#a6e22e">reset</span>(<span style="color:#a6e22e">count</span> <span style="color:#66d9ef">uint32</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span> = <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span> = <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>[:<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#ae81ff">1</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 初始化素数集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">count</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span> = append(<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ord</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomOrder</span>) <span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#a6e22e">randomEnum</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">randomEnum</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">count</span>: <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pos</span>:   <span style="color:#a6e22e">i</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">count</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">inc</span>:   <span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">%</span>uint32(len(<span style="color:#a6e22e">ord</span>.<span style="color:#a6e22e">coprimes</span>))],
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">done</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span> = (<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">inc</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">randomEnum</span>) <span style="color:#a6e22e">position</span>() <span style="color:#66d9ef">uint32</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">pos</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#66d9ef">uint32</span> { <span style="color:#75715e">// 辗转相除法取最大公约数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">%</span><span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">8</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">order</span> <span style="color:#a6e22e">randomOrder</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">reset</span>(uint32(len(<span style="color:#a6e22e">arr</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;====第一次随机遍历====&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">enum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Uint32</span>()); !<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">done</span>(); <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">position</span>()])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;====第二次随机遍历====&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">enum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">order</span>.<span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Uint32</span>()); !<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">done</span>(); <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">position</span>()])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="fisheryates-shuffle">
  Fisher–Yates shuffle
  <a class="anchor" href="#fisheryates-shuffle">#</a>
</h3>
<h2 id="进一步阅读">
  进一步阅读
  <a class="anchor" href="#%e8%bf%9b%e4%b8%80%e6%ad%a5%e9%98%85%e8%af%bb">#</a>
</h2>
<ul>
<li>
  <a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a></li>
<li>
  <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm">Fisher–Yates_shuffle</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">
<div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "go-cyub-vip" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
</body>
</html>












